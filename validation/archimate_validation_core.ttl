@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix dct: <http://purl.org/dc/terms/> .
@prefix archimate: <https://purl.org/archimate#> .
@base <https://purl.org/archimate/validation#> .

### SHACL Validation for ArchiMate Basic Constraints
<#> rdf:type owl:Ontology ;
    owl:imports <https://purl.org/archimate/owl> ;
    rdfs:label "ArchiMate Basic Validation Rules" ;
    rdfs:comment "Level 1 Core Validation: universal model quality and graph integrity constraints. Validates concept requirements (identifier, name, documentation), specialization relationship integrity, relationship structural integrity (composition/aggregation rules, RDF-Star metadata), and model quality checks. For metamodel pattern rules, see archimate_validation_metamodel.ttl. For per-element-type relationship combinations, see archimate_validation_<layer>.ttl." ;
    dct:creator "Alberto D. Mendoza" ;
    dct:created "2026-02-10"^^xsd:date ;
    dct:modified "2026-02-20"^^xsd:date ;
    owl:versionInfo "Alpha" ;
    sh:declare [
        sh:prefix "archimate" ;
        sh:namespace "https://purl.org/archimate#"^^xsd:anyURI ;
    ] , [
        sh:prefix "rdf" ;
        sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#"^^xsd:anyURI ;
    ] , [
        sh:prefix "rdfs" ;
        sh:namespace "http://www.w3.org/2000/01/rdf-schema#"^^xsd:anyURI ;
    ] , [
        sh:prefix "owl" ;
        sh:namespace "http://www.w3.org/2002/07/owl#"^^xsd:anyURI ;
    ] .


### NOTES
# Level 1 Core Validation — Universal model quality and graph integrity.
#
# This file focuses on:
# - Universal concept requirements (identifier, name, documentation)
# - Concept uniqueness constraints
# - Specialization relationship validation (same-type constraint, depth check)
# - Model completeness checks (orphaned elements, singletons)
# - Relationship structural integrity (no circular/self composition/aggregation,
#   composition part uniqueness)
# - Relationship quality checks (redundant relationships, missing metadata)
#
# Note: specialization is purely a relationship (not a concept property).
# Instance-to-type mapping uses rdf:type. See ontology Section 5.4.
#
# Organization:
# - Section 1: Universal Concept Requirements
# - Section 2: Model Completeness Quality Check
# - Section 3: Specialization Relationship Validation (same-type, depth)
# - Section 4: Structural Relationship Validation (composition, aggregation)
# - Section 5: Relationship Quality Checks
#
# This validation file should be used alongside:
# - archimate_validation_metamodel.ttl (Level 2: abstract metamodel pattern rules)
# - archimate_validation_<layer>.ttl (Level 3: per-element-type relationship combinations)
# - archimate_derivation_rules.ttl (derivation rules)
# - archimate_validation_profiles.ttl (profile-specific shapes)
#
# Validation severity levels:
# - sh:Violation (default): Hard constraint violations
# - sh:Warning: Issues that should be reviewed
# - sh:Info: Quality suggestions and informational notices
#
# owl:imports note:
# The ontology declares @base <https://purl.org/archimate#> so its IRI is
# <https://purl.org/archimate#>. We import <https://purl.org/archimate/owl>
# which is the PURL that redirects to the raw Turtle file. These URIs differ
# but engines resolve owl:imports by dereferencing the URL, so the import
# works. purl.org does not support content negotiation (Accept headers) —
# separate PURLs are used for each representation (/archimate → SKOS HTML,
# /archimate/owl → OWL Turtle).
#
# To execute validation:
# 1. Load base ArchiMate ontology (archimate.ttl)
# 2. Load this validation file (Level 1)
# 3. Load archimate_validation_metamodel.ttl (Level 2)
# 4. Load archimate_validation_<layer>.ttl files (Level 3, optional)
# 5. Load your model data
# 6. Run SHACL validation


### 1. Universal Concepts Requirements

# All realized elements and relationships must have required attributes
<#RealizedConceptShape> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Concept ;
    rdfs:label "Realized Concept Requirements" ;
    sh:property [
        sh:path archimate:identifier ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:datatype xsd:string ;
        sh:pattern "^[a-zA-Z_][a-zA-Z0-9_-]*$" ;
        sh:message "All realized concepts must have exactly one valid identifier"
    ] ;
    sh:property [
        sh:path archimate:name ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:datatype xsd:string ;
        sh:message "All realized concepts must have exactly one name"
    ] ;
    sh:property [
        sh:path archimate:documentation ;
        sh:maxCount 1 ;
        sh:datatype xsd:string ;
        sh:message "All realized concepts must have at most one documentation value"
    ] .

# Unique identifier constraint across all concepts
<#UniqueConceptIdentifier> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Concept ;
    rdfs:label "Unique Concept Identifier Constraint" ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Concept identifiers must be unique across the model" ;
        sh:select """
            SELECT $this ?other WHERE {
                $this archimate:identifier ?id .
                ?other archimate:identifier ?id .
                FILTER($this != ?other)
            }
        """
    ] .



### 2. Model Completeness Validation

# Check for orphaned elements (no relationships)
<#OrphanedElementShape> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Element ;
    rdfs:label "Connected Elements" ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Elements should participate in at least one relationship" ;
        sh:severity sh:Info ;
        sh:select """
            SELECT $this WHERE {
                # Exclude Grouping and Location elements (they can exist independently)
                FILTER NOT EXISTS {
                    $this rdf:type/rdfs:subClassOf* archimate:Grouping
                }
                FILTER NOT EXISTS {
                    $this rdf:type/rdfs:subClassOf* archimate:Location
                }

                # Check if element has any relationships
                FILTER NOT EXISTS {
                    { $this ?p ?o . ?p rdfs:subPropertyOf+ archimate:structuralRelationship } UNION
                    { $this ?p ?o . ?p rdfs:subPropertyOf+ archimate:dependencyRelationship } UNION
                    { $this ?p ?o . ?p rdfs:subPropertyOf+ archimate:dynamicRelationship } UNION
                    { ?s ?p $this . ?p rdfs:subPropertyOf+ archimate:structuralRelationship } UNION
                    { ?s ?p $this . ?p rdfs:subPropertyOf+ archimate:dependencyRelationship } UNION
                    { ?s ?p $this . ?p rdfs:subPropertyOf+ archimate:dynamicRelationship }
                }
            }
        """
    ] .

# Check for singleton elements (only one instance of an element type)
<#SingletonElementCheck> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Element ;
    rdfs:label "Singleton Element Check" ;
    sh:severity sh:Info ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Only one instance of this element type exists in the model - consider if this is intentional" ;
        sh:select """
            SELECT $this WHERE {
                $this rdf:type ?elementType .
                ?elementType rdfs:subClassOf+ archimate:Element .

                # Count instances of this element type
                {
                    SELECT ?elementType (COUNT(?instance) AS ?instanceCount) WHERE {
                        ?instance rdf:type ?elementType .
                    }
                    GROUP BY ?elementType
                }

                FILTER(?instanceCount = 1)
            }
        """
    ] .



### 3. Specialization Relationship Validation
# Specialization is purely a relationship (spec Section 5.4), not a concept property.
# It connects two elements/concepts of the same type (e.g., specialized process → generic process).

# Specialization must connect same-type elements
<#SpecializationSameType> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Concept ;
    rdfs:label "Specialization Same-Type Constraint" ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Specialization relationship must connect elements of the same type (e.g., BusinessProcess can only specialize BusinessProcess)" ;
        sh:select """
            SELECT $this WHERE {
                $this archimate:specialization ?target .

                # Get the ArchiMate types of source and target
                $this rdf:type ?sourceType .
                ?target rdf:type ?targetType .

                # Only check concrete ArchiMate element types
                ?sourceType rdfs:subClassOf+ archimate:Element .
                ?targetType rdfs:subClassOf+ archimate:Element .

                # Source and target must share at least one common ArchiMate type
                FILTER NOT EXISTS {
                    $this rdf:type ?commonType .
                    ?target rdf:type ?commonType .
                    ?commonType rdfs:subClassOf+ archimate:Element .
                }
            }
        """
    ] .

# No self-specialization
<#NoSelfSpecialization> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Concept ;
    rdfs:label "No Self-Specialization" ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "An element cannot specialize itself" ;
        sh:select """
            SELECT $this WHERE {
                $this archimate:specialization $this
            }
        """
    ] .

# Check for overly deep specialization chains
<#DeepSpecializationCheck> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Concept ;
    rdfs:label "Deep Specialization Chain Check" ;
    sh:severity sh:Info ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Element has a deep specialization chain (5+ levels) - consider if this complexity is necessary" ;
        sh:select """
            SELECT $this WHERE {
                # Check specialization depth via transitive property
                # 4 chained steps with + = minimum 5 hops
                $this archimate:specialization+ ?type1 .
                ?type1 archimate:specialization+ ?type2 .
                ?type2 archimate:specialization+ ?type3 .
                ?type3 archimate:specialization+ ?type4 .
            }
        """
    ] .



### 4. Structural Relationship Validation

## 4.1 Composition Relationships

# No self-composition
<#NoSelfComposition> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Element ;
    rdfs:label "No Self-Composition" ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Elements cannot compose themselves" ;
        sh:select """
            SELECT $this WHERE {
                $this archimate:composition $this
            }
        """
    ] .

# No circular composition
<#NoCircularComposition> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Element ;
    rdfs:label "No Circular Composition" ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Circular composition relationships are not allowed (A composes B, B composes C, C composes A)" ;
        sh:select """
            SELECT $this WHERE {
                $this archimate:composition+ $this
            }
        """
    ] .

# Composition part uniqueness: a part can only belong to one whole
<#CompositionPartUniqueness> rdf:type sh:NodeShape ;
    sh:targetObjectsOf archimate:composition ;
    rdfs:label "Composition Part Uniqueness" ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "A composed part can only belong to one whole (composition implies exclusive ownership)" ;
        sh:select """
            SELECT $this WHERE {
                ?whole1 archimate:composition $this .
                ?whole2 archimate:composition $this .
                FILTER(?whole1 != ?whole2)
            }
        """
    ] .


## 4.2 Aggregation Relationships

# No self-aggregation
<#NoSelfAggregation> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Element ;
    rdfs:label "No Self-Aggregation" ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Elements cannot aggregate themselves" ;
        sh:select """
            SELECT $this WHERE {
                $this archimate:aggregation $this
            }
        """
    ] .

# No circular aggregation
<#NoCircularAggregation> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Element ;
    rdfs:label "No Circular Aggregation" ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Circular aggregation relationships are not allowed" ;
        sh:select """
            SELECT $this WHERE {
                $this archimate:aggregation+ $this
            }
        """
    ] .



### 5. Relationship Quality Checks

## Check for redundant relationships
<#RedundantRelationshipCheck> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Concept ;
    rdfs:label "Redundant Relationship Check" ;
    sh:severity sh:Info ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Redundant relationship detected: same relationship type between same elements exists multiple times" ;
        sh:select """
            SELECT $this WHERE {
                $this ?rel ?target .

                # Only consider ArchiMate relationship properties
                { ?rel rdfs:subPropertyOf+ archimate:structuralRelationship }
                UNION { ?rel rdfs:subPropertyOf+ archimate:dependencyRelationship }
                UNION { ?rel rdfs:subPropertyOf+ archimate:dynamicRelationship }

                # Count how many times this exact relationship exists
                {
                    SELECT ?source ?rel ?target (COUNT(*) AS ?count) WHERE {
                        ?source ?rel ?target .
                    }
                    GROUP BY ?source ?rel ?target
                }

                FILTER(?source = $this)
                FILTER(?count > 1)
            }
        """
    ] .

## Check for potentially missing relationship metadata
<#MissingRelationshipMetadataWarning> rdf:type sh:NodeShape ;
    sh:targetClass archimate:Concept ;
    rdfs:label "Missing Relationship Metadata Warning" ;
    sh:severity sh:Warning ;
    sh:sparql [
        sh:prefixes <#> ;
        sh:message "Relationship exists but is missing name or documentation (only identifier present)" ;
        sh:select """
            SELECT $this WHERE {
                $this ?rel ?target .
                <<$this ?rel ?target>> archimate:identifier ?id .

                # Only consider ArchiMate relationship properties
                { ?rel rdfs:subPropertyOf+ archimate:structuralRelationship }
                UNION { ?rel rdfs:subPropertyOf+ archimate:dependencyRelationship }
                UNION { ?rel rdfs:subPropertyOf+ archimate:dynamicRelationship }

                FILTER NOT EXISTS {
                    <<$this ?rel ?target>> archimate:name ?name .
                }
                FILTER NOT EXISTS {
                    <<$this ?rel ?target>> archimate:documentation ?doc .
                }
            }
        """
    ] .
